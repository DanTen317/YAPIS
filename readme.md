# Спецификация языка программирования ListLang

## 1. Описание

ListLang — это императивный язык программирования со статической компиляцией в WebAssembly (WASM). Язык поддерживает
неявную типизацию, автоматическое управление памятью для списковых структур (bump allocation), полиморфные списки (
хранение данных разных типов) и синтаксис, зависящий от отступов (Python-like).

## 2. Типы данных

Язык поддерживает следующие встроенные типы:

1. **int**: 32-битное целое число со знаком.
2. **float**: 32-битное число с плавающей точкой.
3. **bool**: Логический тип (`true` / `false`), представлен как `1` и `0`.
4. **string**: Строковый литерал (хранится в секции данных WASM).
5. **list**: Динамический массив, способный хранить элементы различных типов (`int`, `float`, `string`) одновременно.
   Реализован через упаковку (boxing) значений.

## 3. Объявление переменных и областей видимости

### 3.1. Переменные

Объявление переменных происходит **неявно** при первом присваивании. Тип переменной выводится компилятором на основе
присваиваемого значения.

**Синтаксис:**

```python
имя_переменной = выражение
цель1, цель2 = выражение1, выражение2  # Множественное присваивание
```

**Примеры:**

```python
x = 10  # Тип int
pi = 3.14  # Тип float
s = "Hello"  # Тип string
ls = [1, 2.5]  # Тип list
a, b = 1, 2  # Множественное присваивание
```

### 3.2. Область видимости

* Поддерживаются **глобальная** область видимости (вне функций) и **локальная** (внутри функций).
* Переменные, объявленные внутри функции, не видны снаружи.

---

## 4. Подпрограммы (Функции)

Функции объявляются с использованием ключевого слова `func`. Блок кода функции определяется отступами.

**Синтаксис:**

```python
func
имя_функции(параметр1, параметр2):
тело_функции
return выражение
```

**Особенности:**

* **Перегрузка:** Поддерживается перегрузка функций по количеству аргументов (name mangling).
* **Возврат значения:** Функция может возвращать значение с помощью `return`. Если `return` отсутствует или не имеет
  аргумента, функция считается процедурой (`void`).
* **Параметры:** Типы параметров выводятся автоматически при компиляции.
* **Передача параметров:** По умолчанию передача осуществляется **по значению**.
    * *Примечание:* Синтаксис поддерживает оператор `&` (например, `func foo(&a)`), но в текущей реализации компилятора
      это эквивалентно передаче по значению (копия в локальную переменную).

**Пример:**

```python
func
add(a, b):
return a + b

func
square(x):
return x * x
```

---

## 5. Операции над данными

### 5.1. Арифметические и логические операции

Поддерживается стандартный набор операций. При операциях между `int` и `float` происходит неявное приведение к `float`.

| Оператор | Описание | Применимость |
| :--- | :--- | :--- |
| `+` | Сложение | `int`, `float` |
| `-` | Вычитание | `int`, `float` |
| `*` | Умножение | `int`, `float` |
| `/` | Деление | `int`, `float` (целочисленное для int) |
| `%` | Остаток от деления | `int` |
| `==`, `!=` | Равно, Не равно | Все типы |
| `<`, `>`, `<=`, `>=` | Сравнение | `int`, `float` |
| `&&`, `||`, `!` | Логическое И, ИЛИ, НЕ | `bool` (выражения) |

### 5.2. Операции над списками

Списки являются полиморфными (гетерогенными).

1. **Литерал списка:** `ls = [1, 2.5, "text"]`
2. **Конкатенация (`+`):** Создает новый список, объединяя два операнда.
   ```python
   res = list1 + list2
   ```
3. **Добавление элемента:** Метод `.add()`.
   ```python
   ls.add(10)
   ls.add(x + y)
   ```
4. **Получение элемента:** Метод `.get()`. Возвращает распакованное значение.
   ```python
   val = ls.get(0)
   ```
5. **Длина списка:** Метод `.len()`.
   ```python
   size = ls.len()
   ```

---

## 6. Управляющие конструкции

Все управляющие конструкции используют двоеточие `:` и отступы для обозначения блоков кода.

### 6.1. Условный оператор (If-Else)

```python
if условие:
    операторы
else:
    операторы
```

### 6.2. Цикл While

Выполняется, пока условие истинно.

```python
while условие:
    операторы
```

### 6.3. Цикл For (Итератор)

Проходит по всем элементам списка. На каждой итерации переменная цикла получает *значение* элемента списка (
автоматическая распаковка).

```python
for элемент in список:
    операторы
```

### 6.4. Оператор выбора (Switch-Case)

Многовариантное ветвление.

```python
switch
выражение:
case
значение1:
операторы
case
значение2:
операторы
default:
операторы
```

### 6.5. Переходы

* `break`: Досрочный выход из циклов (`while`, `for`) или `switch`.
* `return`: Возврат из функции.

---

## 7. Встроенные функции и ввод/вывод

Язык предоставляет набор встроенных функций (intrinsics), которые транслируются в специфичный WASM-код или вызовы
окружения.

1. **`write(arg1, arg2, ...)`**:
    * Выводит аргументы на стандартный вывод.
    * Поддерживает вывод `int`, `float`, `string` и `list` (в формате `[1, 2, 3]`).
    * Автоматически определяет тип аргумента.

2. **`read()`**:
    * Считывает целое число из стандартного ввода.
    * Возвращает `int`.

3. **`swap(a, b)`**:
    * Меняет местами значения двух переменных.
    * Работает с любыми типами данных.

---

## 8. Особенности реализации (WASM Target)

1. **Типизация:** Хотя синтаксис выглядит динамическим, компилятор производит вывод типов (Type Inference) во время
   компиляции на основе литералов и операций.
2. **Хранение списков:**
    * Списки хранятся в куче (Heap) начиная со смещения 1024.
    * Используется структура "Заголовок" (размер, указатель на данные) + "Массив указателей на Ячейки".
    * Каждая "Ячейка" (Cell) хранит тег типа (int/float/string) и само значение.
3. **Арифметика в списках:** При извлечении элемента из списка для арифметической операции происходит **Runtime Unboxing
   ** — проверка типа в ячейке и извлечение значения.

## 9. Файлы грамматики:

Lexer:
[ListLangLexer.g4](ListLangLexer.g4)

Parser:
[ListLangParser.g4](ListLangParser.g4)

Дополнительно разработаны классы:

- [ListLangDenterHelper](ListLangDenterHelper.py) для обработки python-like отступов. Он расставляет токены indent и
  dedent для обозначения уровней текста. Это упрощает построение дерева.
- Стандартный ErrorListener из antlr4 был заменен на [синтаксический анализатор](CustomErrorListener.py), который
  выводит позицию и символ ошибки при парсинге файла.
- Разработан [семантичекий анализатор](semantic_analyser.py), определяющий следующие ошибки:

#### Ошибки при работе с функциями

- **Return вне функции**
  Использование оператора return в глобальной области видимости (не внутри тела функции).
- Неопределенная функци
  Попытка вызвать функцию, которая не была объявлена ранее.
- **Вызов не-функции**
  Попытка использовать переменную или другой объект как функцию (например, x = 5; x()).
- **Несовпадение количества аргументов** (Function expects X arguments, got Y)
  Вызов функции с неправильным количеством передаваемых параметров (кроме встроенной функции write).

#### Ошибки при работе с переменными и объектами

- **Неопределенная переменная** (Undefined variable)
  Использование переменной в выражении (справа от =), которая еще не была объявлена (не получала значения).
- **Неопределенный объект** (Undefined object)
  Попытка вызвать метод у переменной, которая не существует (например, unknownVar.add(1)).
- **Несоответствие количества переменных при присваивании** (Assignment mismatch)
  Количество переменных слева не совпадает с количеством выражений справа (например, a, b = 1 или a = 1, 2).

#### Ошибки типов и операций

- **Несовместимые типы в арифметике** (Incompatible types for arithmetic)
  Попытка выполнить арифметические операции (+, -, *, /, %) над несовместимыми типами (например, int + string, за
  исключением конкатенации строк, которая разрешена, или int + bool).
  Примечание: Операции с типом element (неизвестный тип) разрешаются.
- **Неизвестный метод** (Unknown method)
  Вызов метода, который не поддерживается встроенными типами list или tree (разрешены только: add, get, len, remove,
  insert, merge).
- **Итерация по неитерируемому типу** (For loop over non-iterable type)
  Попытка использовать в цикле for выражение, которое не является списком, деревом, строкой или элементом (например, for
  x in 10:).

# Описание работы компилятора

Для компилятора был написан отдельный класс для построения AST [ast_builder.py](compiler/ast_builder.py), а также классы
вершин AST для него [ast_nodes.py](compiler/ast_nodes.py).
Сам компилятор: [compiler.py](compiler/compiler.py)

Для выполнения кода написан скрипт [run.py](run.py)

Аргументы:

- `file`  Path to the source file
- `--wat` Output WAT filename
- `--wasm` Output WASM filename
- `--runner` Path to runner.js

Cкомпилированный WASM выполняется с помощью `Node.js`, скрипт для запуска написан в [runner.js](runner.js)

``` sh
python run.py testfiles/test1.txt
 
--- [1/4] Reading testfiles/test1.txt ---
--- [2/4] Compiling to WAT ---
Saved to output.wat
--- [3/4] Converting to WASM (via python-wabt) ---

Saved to output.wasm
--- [4/4] Running via Node.js ---
...
```

## Примеры работы компилятора:

### Пример 1

#### Код:

```python
func
multiply(a, b):
return a * b  # операция *

func
multiply(a):
return a * a
func
division( & a, b):  # Передача по результату и по значению
a = 2
return a / b
myList = []
x = 10
y = 5.2
n, m = 2, 2
nm = division(n, m)
write(n)  # 2
write(nm)  # 2
myList.add(x)
myList.add(y)
myList.add(x + y)  # Операция + и неявное преобразование типов
if myList.len() > 2:
    write("More than 2 in list")
else:
    write("list is short")
sum = 0
for el in myList:
    sum = sum + el  # операция +
write("element summ: ", sum)

arg1 = myList.get(0)
arg2 = myList.get(1)
write("mult of 2 first: ", multiply(arg1, arg2))
```

### Вывод:

```
--- Starting Program ---
[Output Int]: 2
[Output Int]: 1
[Output String]: More than 2 in list
[Output String]: element summ: 
[Output Int]: 30
[Output String]: mult of 2 first: 
[Output Int]: 50
--- End Program ---
```

### Пример 2

#### Код:

```python
func
multiply(a, b):
return a * b  # операция *

func
multiply(a):
return a * a
func
division( & a, b):  # Передача по результату и по значению
a = 2
return a / b
myList = []
x = 10
y = 5.2
n, m = 2, 2
nm = division(n, m)
write(n)  # 2
write(nm)  # 2
myList.add(x)
myList.add(y)
myList.add(x + y)  # Операция + и неявное преобразование типов
if myList.len() > 2:
    write("More than 2 in list")
else:
    write("list is short")
sum = 0
for el in myList:
    sum = sum + el  # операция +
write("element summ: ", sum)

arg1 = myList.get(0)
arg2 = myList.get(1)
write("mult of 2 first: ", multiply(arg1, arg2))
```

### Вывод:

```
--- Starting Program ---
[Output Int]: 2
[Output Int]: 1
[Output String]: More than 2 in list
[Output String]: element summ: 
[Output Int]: 30
[Output String]: mult of 2 first: 
[Output Int]: 50
--- End Program ---
```

### Пример 2

#### Код:

``` python
func sw(x, &y):
    x, y = y, x
    return x, y
a, b, c = 5, 10, 15
lst = []
lst.add(a)
lst.add(b)
lst.add(c)
write(lst)
```

```
--- Starting Program ---
[5, 10, 15]
--- End Program ---
```

```python
func
multiply(a, b):
return a * b

myList = []
myList.add(10)
myList.add(20.5)
myList.add(30)

write("List len = ", myList.len())

sum = 0
for el in myList:
    sum = sum + el  # float элемент будет приведен к int, т.к. sum - int

write(sum)  # 60
write(myList)  # [10, 20.5, 30]
```

### Вывод:

```
--- Starting Program ---
[Output String]: List len = 
[Output Int]: 3
[Output Int]: 60
[10, 20.5, 30]
--- End Program ---
```